#![allow(non_snake_case)]

mod generated;

use std::{thread, cell::RefCell};
use protobuf::Message;
use tonic::{transport::Server, Request, Response, Status};
use diesel::{pg::PgConnection, prelude::*};
use amiquip::{QueueDeclareOptions, ConsumerOptions, ConsumerMessage, Result};
use generated::{
    proto::{
        create_profile::CreateProfileRequest,
        profile::{
            DeleteProfileRequest, DeleteProfileResponse,
            profile_server::{ProfileServer, Profile}
        }
    },
    diesel::{schema::profiles as ProfileSchema, models::Profile as ProfileModel}
};

struct Database {
    connection: PgConnection
}

impl Database {
    fn createConnection( ) -> Self {
        let databaseUri= "postgresql://root@localhost:26257/profile?sslmode=disable";

        let connection= PgConnection::establish(databaseUri)
            .expect("ðŸ’€ error connecting to cockroachDB");

        println!("ðŸ”¥ connected to cockroachDB");

        return Database { connection };
    }

    fn createProfile(&mut self, profile: &ProfileModel) -> Result<usize, diesel::result::Error> {
        return diesel::insert_into(ProfileSchema::table)
            .values(profile)
            .execute(&mut self.connection);
    }

    fn deleteProfile(&mut self, email: &str) -> Result<usize, diesel::result::Error> {
        return diesel::delete(
            ProfileSchema::table.filter(
                Box::new(ProfileSchema::email.eq(email))
            )
        )
            .execute(&mut self.connection);
    }
}

thread_local! {
    //* connecting to cockroachDB
    static DATABASE: RefCell<Database>= RefCell::new(Database::createConnection( ));
}

fn consumeFromRabbitMQ( ) -> Result<( )> {
    use amiquip::Connection;

    let mut connection= Connection::insecure_open(
        "amqp://user:password@localhost:5672")?;
    println!("ðŸ”¥ connected to rabbitMQ");

    let channel= connection.open_channel(None)?; // channel id is automatically generated by the library

    thread::spawn(
        move | | -> amiquip::Result<( )> {
            let queue= channel.queue_declare("profile", QueueDeclareOptions::default( ))?;

            let consumer= queue.consume(
                ConsumerOptions {
                    no_ack: true,

                    ..ConsumerOptions::default( )
                }
            )?;

            for message in consumer.receiver( ).iter( ) {
                match message {

                    ConsumerMessage::Delivery(message) => {
                        let messageBody= message.clone( ).body;

                        let mut createProfileRequest= CreateProfileRequest::new( );

                        if createProfileRequest.merge_from_bytes(&messageBody).is_ok( ) {

                            let result= DATABASE.with(
                                move |refCell| {
                                    let mut database= refCell.borrow_mut( );
                    
                                    return database.createProfile(
                                        &ProfileModel {
                                            id: None,
                                            name: createProfileRequest.name,
                                            email: createProfileRequest.email
                                        }
                                    );
                                }
                            );

                            let _= match result {
                                Ok(_) => message.ack(&channel),

                                Err(error) => {
                                    println!("ðŸ’€ error creating profile : {}", error);

                                    Ok(( ))
                                }
                            };

                        } else {
                            println!("unknown type of message received from rabbitMQ");
                        }
                    }

                    _ => println!("unknown type of message received from rabbitMQ")
                }
            }

            return Ok(( ));
        }
    );

    return Ok(( ));
}

#[derive(Default)]
struct ImplementedProfileService { }

#[tonic::async_trait]
impl Profile for ImplementedProfileService {

    async fn delete_profile(&self, request: Request<DeleteProfileRequest>) -> Result<Response<DeleteProfileResponse>, Status> {
        let email= String::from(request.into_inner( ).email);

        let result= DATABASE.with(
            move |refCell| {
                let mut database= refCell.borrow_mut( );

                return database.deleteProfile(&email);
            }
        );

        match result {
            Ok(_) => { },

            Err(error) => println!("ðŸ’€ error deleting profile from database : {}", error)
        }

        return Ok(Response::new(
            DeleteProfileResponse { optional_error: None }
        ));
    }
}

#[tokio::main]
async fn main( ) -> Result<( ), Box<dyn std::error::Error>> {

    //* connect to rabbitMQ and start consuming messages in a separate thread
    consumeFromRabbitMQ( )
        .expect("ðŸ’€ error connecting to rabbitMQ");

    //* creating gRPC reflection service

    let reflectionService= tonic_reflection::server::Builder::configure( )
        .register_encoded_file_descriptor_set(
            tonic::include_file_descriptor_set!("profile_descriptor")
        )
        .build( )
        .unwrap( );

    //* starting the gRPC server

    let implementedProfileService= ImplementedProfileService::default( );

    let socketAddress= "0.0.0.0:4000".parse( ).unwrap( );
    println!("ðŸ”¥ starting gRPC server");

    Server::builder( )
        .add_service(ProfileServer::new(implementedProfileService))
        .add_service(reflectionService)
        .serve(socketAddress)
        .await?;

    return Ok(( ));
}