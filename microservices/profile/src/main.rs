#![allow(non_snake_case)]

mod generated;

use std::thread;
use protobuf::Message;
use tonic::{transport::Server, Request, Response, Status};
use diesel::{pg::PgConnection};
use amiquip::{QueueDeclareOptions, ConsumerOptions, ConsumerMessage, Result};
use generated::{
    proto::{
        create_profile::CreateProfileRequest,
        profile::{
            DeleteProfileRequest, DeleteProfileResponse,
            profile_server::{ProfileServer, Profile}
        }
    },
    diesel::{schema::profiles, models}
};

struct Database {
    connection: PgConnection
}

impl Database {
    fn createConnection( ) -> Self {
        use diesel::Connection;

        let databaseUri= "postgresql://root@localhost:26257/defaultdb?sslmode=disable";

        let connection= PgConnection::establish(databaseUri)
            .expect("ðŸ’€ error connecting to cockroachDB");

        println!("ðŸ”¥ connected to cockroachDB");

        return Database { connection };
    }

    fn createProfile(&self, profile: &models::Profile) { }

    fn deleteProfile(&self, email: &str) { }
}

fn consumeFromRabbitMQ( ) -> Result<( )> {
    use amiquip::Connection;

    let mut connection= Connection::insecure_open(
        "amqp://user:password@localhost:5672")?;
    println!("ðŸ”¥ connected to rabbitMQ");

    let channel= connection.open_channel(None)?; // channel id is automatically generated by the library

    thread::spawn(
        move | | -> amiquip::Result<( )> {
            let queue= channel.queue_declare("profile", QueueDeclareOptions::default( ))?;

            let consumer= queue.consume(ConsumerOptions::default( ))?;

            for message in consumer.receiver( ).iter( ) {
                match message {

                    ConsumerMessage::Delivery(message) => {
                        let messageBody= message.body;

                        let mut createProfileRequest= CreateProfileRequest::new( );

                        if createProfileRequest.merge_from_bytes(&messageBody).is_ok( ) {

                            println!("received message from rabbitMQ !");
                            todo!( )

                        } else {
                            println!("unknown type of message received from rabbitMQ");
                        }
                    }

                    _ => println!("unknown type of message received from rabbitMQ")
                }
            }

            return Ok(( ));
        }
    );

    return Ok(( ));
}

#[derive(Default)]
struct ImplementedProfileService { }

#[tonic::async_trait]
impl Profile for ImplementedProfileService {
    async fn delete_profile(&self, request: Request<DeleteProfileRequest>) -> Result<Response<DeleteProfileResponse>, Status> {

        todo!( )
    }
}

#[tokio::main]
async fn main( ) -> Result<( ), Box<dyn std::error::Error>> {

    //* connect to rabbitMQ and start consuming messages in a separate thread
    consumeFromRabbitMQ( )
        .expect("ðŸ’€ error connecting to rabbitMQ");

    //* connect to cockroachDB
    let database= Database::createConnection( );

    //* starting the gRPC server

    let implementedProfileService= ImplementedProfileService::default( );
    let socketAddress= "0.0.0.0:4000".parse( ).unwrap( );

    println!("ðŸ”¥ starting gRPC server");

    Server::builder( )
        .add_service(ProfileServer::new(implementedProfileService))
        .serve(socketAddress)
        .await?;

    return Ok(( ));
}